(in-package :graph-utils)

(defmethod bipartite? ((graph graph) &key show-partitions?)
  (let ((color-table (make-hash-table))
        (partition-table (make-hash-table))
        (queue (make-empty-queue))
        (components (find-components graph)))
    (flet ((set-color (node color)
             (setf (gethash node color-table) color))
           (color-of (node)
             (gethash node color-table))
           (partition-of (node)
             (gethash node partition-table))
           (set-partition (node p)
             (setf (gethash node partition-table) p)))
      (map-nodes #'(lambda (name n)
                     (declare (ignore name))
                     (set-partition n 0)
                     (set-color n :white))
                 graph)
      (dolist (component components)
        (let ((start (nth (random (length component)) component)))
          (set-partition start 1)
          (enqueue queue start)
          (set-color start :grey)
          (loop until (empty-queue? queue) do
               (let* ((node (dequeue queue)))
                 (dolist (neighbor (neighbors graph node))
                   (when (= (partition-of neighbor) (partition-of node))
                     (return-from bipartite? nil))
                   (when (eql :white (color-of neighbor))
                     (set-color neighbor :gray)
                     (set-partition neighbor (- 3 (partition-of node)))
                     (enqueue queue neighbor)))
                 (set-color node :black)))))
      (if show-partitions?
          (let ((a nil) (b nil))
            (maphash #'(lambda (node p)
                         (if (eq p 1)
                             (push node a)
                             (push node b)))
                     partition-table)
            (values a b))
          t))))

(defmethod compute-maximum-matching ((graph graph))
  (multiple-value-bind (black white) (bipartite? graph :show-partitions? t)
    (if (and black white)
        (let* ((flow-net (copy-graph graph))
               (source (add-node flow-net :source))
               (sink (add-node flow-net :sink)))
          (map-edges #'(lambda (n1 n2)
                         (set-edge-weight flow-net n1 n2 1)
                         ;; Make sure edges go the proper direction
                         (when (member n1 white)
                           (reverse-edge flow-net n1 n2)))
                     flow-net)
          (dolist (node black)
            (add-edge flow-net source node :weight 1))
          (dolist (node white)
            (add-edge flow-net node sink :weight 1))
          ;;(visualize flow-net :render? t :file "data/matching.dot")
          (multiple-value-bind (flow edges)
              (compute-maximum-flow flow-net source sink :dinic)
            (values
             (mapcar #'(lambda (edge)
                         (subseq edge 0 2))
                     (remove-if #'(lambda (edge)
                                    (or (/= 1 (nth 2 edge))
                                        (eq (first edge) source)
                                        (eq (first edge) sink)
                                        (eq (second edge) source)
                                        (eq (second edge) sink)))
                                edges))
             black
             white
             flow)))
        (error "Maximum matching not implemented on non-bipartite graphs"))))
