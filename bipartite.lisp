(in-package :graph-utils)

(defmethod bipartite? ((graph graph) &key color-lists?)
  (let ((color-table (make-hash-table))
        (memory (make-hash-table))
        (queue (make-empty-queue))
        (components (find-components graph)))
    (when (> (length components) 1) (return-from bipartite? nil))
    (flet ((set-color (node color)
             (setf (gethash node color-table) color))
           (color-of (node)
             (gethash node color-table))
           (opposite-of (color)
             (if (eq color :black) :white :black))
           (remember (node)
             (setf (gethash node memory) t))
           (seen? (node)
             (gethash node memory)))
      (flet ((check-neighbor (node neighbor)
               (when (eq (color-of neighbor) (color-of node))
                 (return-from bipartite? nil))
               (set-color neighbor (opposite-of (color-of node)))
               (unless (seen? neighbor)
                 (remember neighbor))))
        (map-nodes #'(lambda (name id) (enqueue queue id)) graph)
        (set-color 0 :black)
        (loop until (empty-queue? queue) do
             (let* ((node (dequeue queue)))
               (dolist (neighbor (neighbors graph node))
                 (check-neighbor node neighbor))))
        (unless (= (node-count graph) (hash-table-count color-table))
          (error "Not all nodes explored!"))
        (if color-lists?
            (let* ((black nil) (white nil))
              (maphash #'(lambda (node color)
                           (if (eq color :black)
                               (push node black)
                               (push node white)))
                       color-table)
              (values black white))
            color-table)))))

(defmethod compute-maximum-matching ((graph graph))
  (multiple-value-bind (black white) (bipartite? graph :color-lists? t)
    (when (and black white)
      (let* ((flow-net (copy-graph graph))
             (source (add-node flow-net :source))
             (sink (add-node flow-net :sink)))
        (dolist (node black)
          (add-edge flow-net source node :weight 1))
        (dolist (node white)
          (add-edge flow-net node sink :weight 1))
        ;;(visualize flow-net :render? t :file "data/matching.dot")
        (multiple-value-bind (flow edges)
            (compute-maximum-flow flow-net source sink
                                  ;;:edmond-karp)
                                  ;;:karvanov
                                  :dinic)
          (declare (ignore flow))
          (values
           (mapcar #'(lambda (edge)
                       (list (nth 0 edge) (nth 1 edge)))
                   (remove-if #'(lambda (edge)
                                  (or (/= 1 (nth 2 edge))
                                      (eq (first edge) source)
                                      (eq (first edge) sink)
                                      (eq (second edge) source)
                                      (eq (second edge) sink)))
                              edges))
           black white))))))

